---
title: JVM学习
author: 丁钧
createTime: 2024/06/13 13:04:10
permalink: /article/33297xi4/
tags:
  - 面试
  - JVM
  - JAVA
---

### 类加载机制

*  虚拟机将class文件加载到内存，并对数据进行校验、解析、转换和初始化，最终形成虚拟机可以识别的Java类型

*  过程：

   * 加载：查找并加载类的二进制文件

   * 验证：确保被加载类的正确性

   * 准备：为类的静态变量分配内存，并对其进行初始化为默认值

   * 解析：将类的符号引用转换为直接引用

   * 初始化：为类的静态变量赋予正确的初始值


   ![img](../images/1.png)

   **需要注意的是：解析不一定在初始化之前，也有可能在初始化之后，为Java运行时绑定做准备**

### JDK1.8和1.9类加载器有何不同？

### 双亲委派机制

![ea3f1967e6604318a07e2289c8cec2ec.png](../images/ea3f1967e6604318a07e2289c8cec2ec.png)

* 当一个calss文件要被加载时（**此处排除自定义加载器**），首先看应用加载器是否加载过，此class文件，没有加载过，则向上找父类加载器，直到BootsrapClassLoader加载器之前都是在验证自己是否加载过，加载过则返回；到BootsrapClassLoader之后，才会验证自己是否能加载，可以的化则直接返回，否则让子类加载器去加载，如果到底层加载器，都无法加载，则会抛出异常（当前class不存在）。

### 双亲委派机制的优缺点？



### JVM内存结构

* 线程私有的：程序计数器、虚拟机栈和本地方法栈
* 线程共享的：方法区和堆内存
* 内存结构：
  * 程序计数器：线程私有且只读的内存区域，**用于保存JVM下一条将要执行指令的地址**
  * Java虚拟机栈：是每个线程运行私有的内存空间，每个方法执行的同时，都会创建一个栈帧，**存储局部变量表、操作数栈、动态链接和方法出入口等**，当方法执行完毕，会从虚拟机栈中弹出，变量的作用域也会结束，数据从此失效
  * 本地方法栈：是一些带有native关键字的方法，用于调用本地的C或C++方法
  * 堆内存：是所有线程共享的一片区域，**虚拟机启动时创建**，存储对象实例，通过new关键字创建的对象，都会使用堆内存，也是垃圾回收的重点区域
  * 方法区：用于存储已被虚拟机加载的类信息、常量、静态变量和即时编译的代码

### Java堆内存是如何进行分代的？

* Java的堆内存，根据不同的存活时期，分为新生代和老年代，新生代和老年代存放的位置不同，有助于提升垃圾回收的效率。
* 新生代一般存放新分配的对象，由一个伊甸区和两个幸存区组成（8：2），当伊甸区内存不够时，**会触发一次GC（minitor Roots，轻GC），通过复制算法进行回收**，GC后存活的对象会被转移到幸存区，当幸存区也满了之后，会移到老年代
* 老年代用来存储长期存活或是大对象的内存空间，由单一内存区域组成，年轻代，经过多轮GC仍然存活的对象，或是刚创建的大对象会被移动到老年代，老年代中大部分对象都会存活很久，**一般采用标记整理算法进行垃圾回收**

### 年轻代里面的对象什么时候进入老年代？

* 躲过15次GC之后，进入老年代
  * 对象每次在年轻代里面躲过一次轻GC，年龄增加一
  * 默认设置下，对象年龄达到15岁时，也就是躲过15次GC后，会被转入老年代
  * 可通过JVM参数：-XX:MaxTenuringThreshould 设置，默认为15
* 动态对象年龄判断
  * 当一批对象的总大小大于幸存区区域的50%时，按照年龄进行排序（age1、age2，age5……ageN），如果age5为50%的分界线，则age5到ageN的对象会直接进入老年代
* 大对象，直接进入老年代
  * 通过参数，-XX:PretenureThresHold设置大对象的阈值，大于此值，则直接进入老年代
* 轻GC后的对象太多，无法放入，幸存区，则会直接放入老年代

### 堆和栈的区别？

* 堆中存储的是实例对象，栈中存储的是本地变量
* 堆是线程共享的，栈是线程私有的
* 栈的大小比堆内存要小，一般是几百到J几千字节
* 堆是垃圾回收的主要区域，不再引用的对象，通过垃圾回收机制自动释放内存；栈的回收是按照先进先出的机制实现的，当方法执行完毕，会将栈帧弹出栈
* 堆会发生内存溢出异常，栈一般是栈溢出异常

### Java对象一定在堆中分配内存吗？

> Java中的对象不一定都在堆中分配内存，也有可能在栈中
>
> 因为HotSpot虚拟机中存在JIT优化。
>
> 而JIT优化可能会进行逃逸分析
>
> 经过分析之后发现，某个对象不会逃逸到线程和方法之外，那这个对象就不会在堆中分配内存，而是在栈中

### 什么是永久代？

* 是指内存的永久保存区域
* 主要被JVM用来存储class和Meta（元信息）信息
* 是HotSpot虚拟机基于JVM规范对方法区的一个落地实现（有人说方法区和永久代等价，其实不严谨，方法区是JVM的规范，永久代是HotSpot虚拟机针对规范的具体实现）
* JDK7及之前是通过永久代，对方法区进行实现
* JDK8及以后通过元空间取代永久代的作用
* 永久代和元空间的区别？
  * 元空间并不在虚拟机中，而是使用本地内存
  * 默认情况下，元空间的内存大小仅受本地内存的限制，但可通过参数来指定元空间的大小
    * -XX:MetaspaceSize：初始空间大小，达到该值，就会触发垃圾回收进行类型卸载，
    * -XX:MaxMetaspaceSize：最大空间，默认没有限制
    * -XX:MinMetaspaceFreeRatio：在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集
    * -XX:MaxMetaspaceFreeRatio：在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集

### GC有哪几种类型？

* 轻GC
  * 针对新生代的垃圾回收，当伊甸区发现内存不足时，会触发轻GC。
  * 执行流程：
    * 当伊甸区发现内存不足时，触发轻GC
    * 伊甸区存活的对象会被转移到幸存区，同时幸存区原有的对象如果还在年龄阈值以下，也会被移动另一个幸存区
    * 达到一定年龄的对象会被转移到老年代
* 重GC
  * 是针对整个堆以及方法区的垃圾回收，因为重GC需要整理整个堆内存和方法区，并会伴随长时间的暂停，重GC要比轻GC的效率要低
  * 处理流程：
    * JVM会暂停所有的垃圾回收，清理整个堆内存和方法区不在使用的对象
    * 有时候还会进行一次堆压缩，整理内存碎片，优化内存使用

### 重GC触发的条件？

* 显式调用system.gc()
  * 代码重执行system.gc()，会触发重GC，但并不保证一定会执行重GC，很多情况下只是增加了重GC的次数
* 老年代空间不足
  * 老年代剩余空间不足以存放从新生代晋升的对象
  * 堆重产生的大对象，会直接放入老年代，但此时老年代空间不足，或是老年代的连续空间不足以存放大对象
* 方法区达到阈值
  * 方法区如果达到分配的内存阈值，也会触发

### 完整的GC流程？

> GC的触发是在对象分配过程重发生的。

* 当一个对象被创建，会先根据其大小，判断进入老年代还是年轻代，**超过（-XX:PretenureThresHold）阈值，会进入老年代，否则年轻代**
* 进入年轻代的对象会先进入伊甸园区，当伊甸园空间不足，**会触发一次轻GC（标记复制算法）**，将伊甸园区和幸存区中国存活的对象移到另一个幸存区，然后清理这两个区域
* 可能会出现两种情况：
  * 幸存区存不了这么多的对象，这时候会触发空间担保（把对象转移到老年代），担保成功则没事，否则会触发重GC
  * 第二种就是会根据对象的年龄进行判断，超出年龄也会转移到老年代，老年代空间不足，则会触发重GC
  * 清理之后还是不够，则抛出OMM异常

### 判断是否可进行垃圾回收的算法？

* 引用计数器：
  * 当对象增加引用时，计数器加一，减少引用时，计数器减一，直到计数器为0，则可回收
  * 缺点是，会出现循环引用的情况，两个对象相互引用，Java虚拟机不再采用此方法
* 可达性分析
  * 通过GcRoots为起点进行搜索，能够到达的对象就是存活的，否则可以回收
  * 可作为GCRoots的对象？
    * 虚拟机栈中引用的对象
    * 本地方法栈引用的对象
    * 方法区中类静态属性或常量引用的对象

### 垃圾回收算法

* 标记清除算法：
  * 将存活的对象进行标记，然后清理掉未被标记的对象
  * 缺点是：会产生大量不连续的内存碎片，导致无法给大对象分配内存
* 标记整理算法：
  * 先采用标记清除确定可回收的对象，然后整理剩余对象，将可用对象移动到一起，使内存紧凑
  * **优点是：内存利用率高，缺点是速度慢**
* 复制算法：
  * 将内存分为两个等大小的区域**from和to（to中为空）**，将GcRoots引用的对象，从from移动到to，再回收from中不再引用的对象，此时交换from和to两片区域
  * **优点是，不会产生碎片，缺点是，只能利用一半的内存空间**
* 分代收集：
  * 根据对象的存活周期，将内存划分为几块，不同块采用不同的算法
  * 一般分为新生代（年轻代）和老年代
  * 新生代：每次都会有大量的对象被回收**（复制算法）**
    * 伊甸区（Eden）：新产生的对象会在这里
    * 幸存区（Survivor）：经过一次，minitor Roots之后会进入幸存区
  * 老年代：每次回收只有少量对象被回收**（标记清除或标记整理）**

![f517b6146b28471b87d0c8ccfb115ee5.png](../images/f517b6146b28471b87d0c8ccfb115ee5.png)

### 为什么在新生代使用复制算法,老年代使用标记整理算法？

### 符号引用和直接引用的区别？

### 类什么时候会被卸载？

### loadClass 和 findClass区别？

