---
title: JVM学习
author: 丁钧
createTime: 2024/06/13 13:04:10
permalink: /article/33297xi4/
tags:
  - 面试
  - JVM
  - JAVA
---

### 1、类加载机制

*  虚拟机将class文件加载到内存，并对数据进行校验、解析、转换和初始化，最终形成虚拟机可以识别的Java类型

*  过程：

   * 加载：查找并加载类的二进制文件

   * 验证：确保被加载类的正确性

   * 准备：为类的静态变量分配内存，并对其进行初始化为默认值

   * 解析：将类的符号引用转换为直接引用

   * 初始化：为类的静态变量赋予正确的初始值


   ![img](../images/1.png)

   **需要注意的是：解析不一定在初始化之前，也有可能在初始化之后，为Java运行时绑定做准备**

### 2、双亲委派机制

![ea3f1967e6604318a07e2289c8cec2ec.png](../images/ea3f1967e6604318a07e2289c8cec2ec.png)

* 当一个calss文件要被加载时（**此处排除自定义加载器**），首先看应用加载器是否加载过，此class文件，没有加载过，则向上找父类加载器，直到BootsrapClassLoader加载器之前都是在验证自己是否加载过，加载过则返回；到BootsrapClassLoader之后，才会验证自己是否能加载，可以的化则直接返回，否则让子类加载器去加载，如果到底层加载器，都无法加载，则会抛出异常（当前class不存在）。

### 3、双亲委派机制的优缺点？

* 优点：
  * 避免重复加载：由于类加载器直接从父类加载器那里加载类，避免了类的重复加载。
  * 提高了安全性：通过双亲委派模型，Java 标准库中的核心类库（如 java.lang.*）由启动类加载器加载，这样能保证这些核心类库不会被恶意代码篡改或替换，从而提高程序的安全性。
  * 保持类加载的一致性：这种方式确保了同一个类的加载由同一个类加载器完成，从而在运行时保证了类型的唯一性和相同性。这也有助于减轻类加载器在处理相互关联的类时的复杂性。
* 缺点：
  * 灵活性降低：由于类加载的过程需要不断地委托给父类加载器，这种机制可能导致实际应用中类加载的灵活性降低。
  * 类加载时间增加：在类加载的过程中，需要不断地查询并委托父类加载器，这意味着类加载所需要的时间可能会增加。在类数量庞大或类加载器层次比较深的情况下，这种时间延迟可能会变得更加明显。

### 4、JVM内存结构

* 线程私有的：程序计数器、虚拟机栈和本地方法栈
* 线程共享的：方法区和堆内存
* 内存结构：
  * 程序计数器：线程私有且只读的内存区域，**用于保存JVM下一条将要执行指令的地址**
  * Java虚拟机栈：是每个线程运行私有的内存空间，每个方法执行的同时，都会创建一个栈帧，**存储局部变量表、操作数栈、动态链接和方法出入口等**，当方法执行完毕，会从虚拟机栈中弹出，变量的作用域也会结束，数据从此失效
  * 本地方法栈：是一些带有native关键字的方法，用于调用本地的C或C++方法
  * 堆内存：是所有线程共享的一片区域，**虚拟机启动时创建**，存储对象实例，通过new关键字创建的对象，都会使用堆内存，也是垃圾回收的重点区域
  * 方法区：用于存储已被虚拟机加载的类信息、常量、静态变量和即时编译的代码

### 5、Java堆内存是如何进行分代的？

* Java的堆内存，根据不同的存活时期，分为新生代和老年代，新生代和老年代存放的位置不同，有助于提升垃圾回收的效率。
* 新生代一般存放新分配的对象，由一个伊甸区和两个幸存区组成（8：2），当伊甸区内存不够时，**会触发一次GC（minitor Roots，轻GC），通过复制算法进行回收**，GC后存活的对象会被转移到幸存区，当幸存区也满了之后，会移到老年代
* 老年代用来存储长期存活或是大对象的内存空间，由单一内存区域组成，年轻代，经过多轮GC仍然存活的对象，或是刚创建的大对象会被移动到老年代，老年代中大部分对象都会存活很久，**一般采用标记整理算法进行垃圾回收**

### 6、年轻代里面的对象什么时候进入老年代？

* 躲过15次GC之后，进入老年代
  * 对象每次在年轻代里面躲过一次轻GC，年龄增加一
  * 默认设置下，对象年龄达到15岁时，也就是躲过15次GC后，会被转入老年代
  * 可通过JVM参数：-XX:MaxTenuringThreshould 设置，默认为15
* 动态对象年龄判断
  * 当一批对象的总大小大于幸存区区域的50%时，按照年龄进行排序（age1、age2，age5……ageN），如果age5为50%的分界线，则age5到ageN的对象会直接进入老年代
* 大对象，直接进入老年代
  * 通过参数，-XX:PretenureThresHold设置大对象的阈值，大于此值，则直接进入老年代
* 轻GC后的对象太多，无法放入，幸存区，则会直接放入老年代

### 7、堆和栈的区别？

* 堆中存储的是实例对象，栈中存储的是本地变量
* 堆是线程共享的，栈是线程私有的
* 栈的大小比堆内存要小，一般是几百到J几千字节
* 堆是垃圾回收的主要区域，不再引用的对象，通过垃圾回收机制自动释放内存；栈的回收是按照先进先出的机制实现的，当方法执行完毕，会将栈帧弹出栈
* 堆会发生内存溢出异常，栈一般是栈溢出异常

### 8、Java对象一定在堆中分配内存吗？

> Java中的对象不一定都在堆中分配内存，也有可能在栈中
>
> 因为HotSpot虚拟机中存在JIT优化。
>
> 而JIT优化可能会进行逃逸分析
>
> 经过分析之后发现，某个对象不会逃逸到线程和方法之外，那这个对象就不会在堆中分配内存，而是在栈中

### 9、什么是永久代？

* 是指内存的永久保存区域
* 主要被JVM用来存储class和Meta（元信息）信息
* 是HotSpot虚拟机基于JVM规范对方法区的一个落地实现（有人说方法区和永久代等价，其实不严谨，方法区是JVM的规范，永久代是HotSpot虚拟机针对规范的具体实现）
* JDK7及之前是通过永久代，对方法区进行实现
* JDK8及以后通过元空间取代永久代的作用
* 永久代和元空间的区别？
  * 元空间并不在虚拟机中，而是使用本地内存
  * 默认情况下，元空间的内存大小仅受本地内存的限制，但可通过参数来指定元空间的大小
    * -XX:MetaspaceSize：初始空间大小，达到该值，就会触发垃圾回收进行类型卸载，
    * -XX:MaxMetaspaceSize：最大空间，默认没有限制
    * -XX:MinMetaspaceFreeRatio：在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集
    * -XX:MaxMetaspaceFreeRatio：在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集

### 10、GC有哪几种类型？

* 轻GC
  * 针对新生代的垃圾回收，当伊甸区发现内存不足时，会触发轻GC。
  * 执行流程：
    * 当伊甸区发现内存不足时，触发轻GC
    * 伊甸区存活的对象会被转移到幸存区，同时幸存区原有的对象如果还在年龄阈值以下，也会被移动另一个幸存区
    * 达到一定年龄的对象会被转移到老年代
* 重GC
  * 是针对整个堆以及方法区的垃圾回收，因为重GC需要整理整个堆内存和方法区，并会伴随长时间的暂停，重GC要比轻GC的效率要低
  * 处理流程：
    * JVM会暂停所有的垃圾回收，清理整个堆内存和方法区不在使用的对象
    * 有时候还会进行一次堆压缩，整理内存碎片，优化内存使用

### 11、重GC触发的条件？

* 显式调用system.gc()
  * 代码重执行system.gc()，会触发重GC，但并不保证一定会执行重GC，很多情况下只是增加了重GC的次数
* 老年代空间不足
  * 老年代剩余空间不足以存放从新生代晋升的对象
  * 堆重产生的大对象，会直接放入老年代，但此时老年代空间不足，或是老年代的连续空间不足以存放大对象
* 方法区达到阈值
  * 方法区如果达到分配的内存阈值，也会触发

### 12、完整的GC流程？

> GC的触发是在对象分配过程重发生的。

* 当一个对象被创建，会先根据其大小，判断进入老年代还是年轻代，**超过（-XX:PretenureThresHold）阈值，会进入老年代，否则年轻代**
* 进入年轻代的对象会先进入伊甸园区，当伊甸园空间不足，**会触发一次轻GC（标记复制算法）**，将伊甸园区和幸存区中国存活的对象移到另一个幸存区，然后清理这两个区域
* 可能会出现两种情况：
  * 幸存区存不了这么多的对象，这时候会触发空间担保（把对象转移到老年代），担保成功则没事，否则会触发重GC
  * 第二种就是会根据对象的年龄进行判断，超出年龄也会转移到老年代，老年代空间不足，则会触发重GC
  * 清理之后还是不够，则抛出OMM异常

### 13、判断是否可进行垃圾回收的算法？

* 引用计数器：
  * 当对象增加引用时，计数器加一，减少引用时，计数器减一，直到计数器为0，则可回收
  * 缺点是，会出现循环引用的情况，两个对象相互引用，Java虚拟机不再采用此方法
* 可达性分析
  * 通过GcRoots为起点进行搜索，能够到达的对象就是存活的，否则可以回收
  * 可作为GCRoots的对象？
    * 虚拟机栈中引用的对象
    * 本地方法栈引用的对象
    * 方法区中类静态属性或常量引用的对象

### 14、垃圾回收算法

* 标记清除算法：
  * 将存活的对象进行标记，然后清理掉未被标记的对象
  * 缺点是：会产生大量不连续的内存碎片，导致无法给大对象分配内存
* 标记整理算法：
  * 先采用标记清除确定可回收的对象，然后整理剩余对象，将可用对象移动到一起，使内存紧凑
  * **优点是：内存利用率高，缺点是速度慢**
* 复制算法：
  * 将内存分为两个等大小的区域**from和to（to中为空）**，将GcRoots引用的对象，从from移动到to，再回收from中不再引用的对象，此时交换from和to两片区域
  * **优点是，不会产生碎片，缺点是，只能利用一半的内存空间**
* 分代收集：
  * 根据对象的存活周期，将内存划分为几块，不同块采用不同的算法
  * 一般分为新生代（年轻代）和老年代
  * 新生代：每次都会有大量的对象被回收**（复制算法）**
    * 伊甸区（Eden）：新产生的对象会在这里
    * 幸存区（Survivor）：经过一次，minitor Roots之后会进入幸存区
  * 老年代：每次回收只有少量对象被回收**（标记清除或标记整理）**

![f517b6146b28471b87d0c8ccfb115ee5.png](../images/f517b6146b28471b87d0c8ccfb115ee5.png)

### 15、为什么在新生代使用复制算法,老年代使用标记整理算法？

> 三种回收算法中，新生代比较适合采用复制算法，一般来说，新生代的垃圾回收要比老年代要多，因此需要一个效率更高的算法，且最好不要有内存碎片，因为很多对象都是在新生代中创建的，如果碎片太多，就会导致很多对象无法正常分配了。所以就选择了标记复制算法，但这个算法存在浪费空间的缺点。为了解决这个问题，就将新生代划分成一个 Eden 区和两个 Suvivor 区，同时工作的只用一个 Eden 区和一个 Suvivor 区，这样，另一个 Suvivor 区主要用来复制就行了。只需要动态调整 Eden 区和 Suvivor 的内存比例就可以降低空间浪费的问题。
>
> 对于老年代来说，通常会采用标记整理算法。虽然效率低一些，但是可以减少空间的浪费且不会存在内存碎片等问题。

### 16、符号引用和直接引用的区别？

* 符号引用：
  * 是一种用来表示引用目标的符号名称，比如说类名、方法名、字段名等。符号引用与实际内存地址无关，只是一个标识符，用来描述被引用的目标。符号引用是在编译期产生的，在编译后的 class 文件中存储
* 直接引用：
  * 是实际指向目标的内存地址，比如说类的实例，方法的字节码等。直接引用与具体的内存地址相关，是在程序运行期间动态生成的

### 17、类什么时候会被卸载？

* 类的卸载由JVM自动完成
* 类不再被引用，且没有活动的实例时，会被卸载



